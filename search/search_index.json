{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dispatch \u00b6 Utilities for kotlinx.coroutines which make them type-safe, easier to test, and more expressive. Use the predefined types and factories or define your own, and never inject a Dispatchers object again. val presenter = MyPresenter ( MainCoroutineScope ()) class MyPresenter @Inject constructor ( /** * Defaults to the Main dispatcher */ val coroutineScope : MainCoroutineScope ) { fun loopSomething () = coroutineScope . launchDefault { } suspend fun updateSomething () = withMainImmediate { } } class MyTest { @Test fun `no setting the main dispatcher` () = runBlockingProvidedTest { // automatically use TestCoroutineDispatcher for every dispatcher type val presenter = MyPresenter ( coroutineScope = this ) // this call would normally crash due to the main looper presenter . updateSomething () } } Contents \u00b6 Injecting dispatchers Types and Factories Referencing dispatchers Builder Extensions Android Lifecycle Android Espresso Android ViewModel Testing Modules Full Gradle Config License Injecting dispatchers \u00b6 Everywhere you use coroutines, you use a CoroutineContext . If we embed the CoroutineDispatchers settings we want into the context, then we don't need to pass them around manually. The core of this library is DispatcherProvider - an interface with properties corresponding to the 5 different CoroutineDispatchers we can get from the Dispatchers singleton. It lives inside the CoroutineContext , and gets passed from parent to child coroutines transparently without any additional code. interface DispatcherProvider : CoroutineContext . Element { override val key : CoroutineContext . Key <*> get () = Key val default : CoroutineDispatcher val io : CoroutineDispatcher val main : CoroutineDispatcher val mainImmediate : CoroutineDispatcher val unconfined : CoroutineDispatcher companion object Key : CoroutineContext . Key < DispatcherProvider > } val someCoroutineScope = CoroutineScope ( Job () + Dispatchers . Main + DispatcherProvider () ) The default implementation of this interface simply delegates to that Dispatchers singleton, as that is what we typically want for production usage. Types and Factories \u00b6 A CoroutineScope may have any type of CoroutineDispatcher . What if we have a View class which will always use the Main thread, or one which will always do I/O? There are marker interfaces and factories to ensure that the correct type of CoroutineScope is always used. Type Dispatcher DefaultCoroutineScope Dispatchers.Default IOCoroutineScope Dispatchers.IO MainCoroutineScope Dispatchers.Main MainImmediateCoroutineScope Dispatchers.Main.immediate UnconfinedCoroutineScope Dispatchers.Unconfined val mainScope = MainCoroutineScope () val someUIClass = SomeUIClass ( mainScope ) class SomeUIClass ( val coroutineScope : MainCoroutineScope ) { fun foo () = coroutineScope . launch { // because of the dependency type, // we're guaranteed to be on the main dispatcher even though we didn't specify it } } Referencing dispatchers \u00b6 These dispatcher settings can then be accessed via extension functions upon CoroutineScope , or the coroutineContext , or directly from extension functions: Builder Extensions \u00b6 Default IO Main Main.immediate Unconfined Job launchDefault launchIO launchMain launchMainImmediate launchUnconfined Deferred asyncDefault asyncIO asyncMain asyncMainImmediate asyncUnconfined suspend T withDefault withIO withMain withMainImmediate withUnconfined Flow<T> flowOnDefault flowOnIO flowOnMain flowOnMainImmediate flowOnUnconfined class MyClass ( val coroutineScope : IOCoroutineScope ) { fun accessMainThread () = coroutineScope . launchMain { // we're now on the \"main\" thread as defined by the interface } } Android Lifecycle \u00b6 The AndroidX.lifecycle library offers a lifecycleScope extension function to provide a lifecycle-aware CoroutineScope , but there are two shortcomings: 1. It delegates to a hard-coded Dispatchers.Main CoroutineDispatcher , which complicates unit and Espresso testing by requiring the use of Dispatchers.setMain . 2. It pauses the dispatcher when the lifecycle state passes below its threshold, which leaks backpressure to the producing coroutine and can create deadlocks . Dispatch-android-lifecycle and dispatch-android-lifecycle-extensions completely replace the AndroidX version. import dispatch.android.lifecycle.* import dispatch.core.* import kotlinx.coroutines.flow.* class MyActivity : Activity () { init { dispatchLifecycleScope . launchOnCreate { viewModel . someFlow . collect { channel . send ( \"$it\" ) } } } } The DispatchLifecycleScope may be configured with any dispatcher, since MainImmediateCoroutineScope is just a marker interface. Its lifecycle-aware functions cancel when dropping below a threshold, then automatically restart when entering into the desired lifecycle state again. This is key to preventing the backpressure leak of the AndroidX version, and it's also more analogous to the behavior of LiveData to which many developers are accustomed. There are two built-in ways to define a custom LifecycleCoroutineScope - by simply constructing one directly inside a Lifecycle class, or by statically setting a custom LifecycleScopeFactory . This second option can be very useful when utilizing an IdlingCoroutineScope . Android Espresso \u00b6 Espresso is able to use IdlingResource to infer when it should perform its actions, which helps to reduce the flakiness of tests. Conventional thread-based IdlingResource implementations don't work with coroutines, however. IdlingCoroutineScope utilizes IdlingDispatchers , which count a coroutine as being \"idle\" when it is suspended. Using statically defined factories, service locators, or dependency injection, it is possible to utilize idling-aware dispatchers throughout a codebase during Espresso testing. class IdlingCoroutineScopeRuleWithLifecycleSample { val customDispatcherProvider = IdlingDispatcherProvider () @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider ( customDispatcherProvider ) } /** * If you don't provide CoroutineScopes to your lifecycle components via a dependency injection framework, * you need to use the `dispatch-android-lifecycle-extensions` and `dispatch-android-viewmodel` artifacts * to ensure that the same `IdlingDispatcherProvider` is used. */ @Before fun setUp () { LifecycleScopeFactory . set { MainImmediateCoroutineScope ( customDispatcherProvider ) } ViewModelScopeFactory . set { MainImmediateCoroutineScope ( customDispatcherProvider ) } } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its \"idle\" state with Espresso } } Android ViewModel \u00b6 The AndroidX ViewModel library offers a viewModelScope extension function to provide an auto-cancelled CoroutineScope , but again, this CoroutineScope is hard-coded and uses Dispatchers.Main . This limitation needn't exist. Dispatch-android-viewmodel doesn't have as many options as its lifecycle counterpart, because the ViewModel.onCleared function is protected and ViewModel does not expose anything about its lifecycle. The only way for a third party library to achieve a lifecycle-aware CoroutineScope is through inheritance. CoroutineViewModel is a simple abstract class which exposes a lazy viewModelScope property which is automatically cancelled when the ViewModel is destroyed. The exact type of the viewModelScope can be configured statically via ViewModelScopeFactory . In this way, you can use IdlingCoroutineScopes for Espresso testing, TestProvidedCoroutineScopes for unit testing, or any other custom scope you'd like. If you're using the AAC ViewModel but not dependency injection, this artifact should be very helpful with testing. import dispatch.android.viewmodel.* import kotlinx.coroutines.flow.* import timber.log.* class MyViewModel : CoroutineViewModel () { init { MyRepository . someFlow . onEach { Timber . d ( \"$it\" ) }. launchIn ( viewModelScope ) } } The DispatchLifecycleScope may be configured with any dispatcher, since MainImmediateCoroutineScope is just a marker interface. Its lifecycle-aware functions cancel when dropping below a threshold, then automatically restart when entering into the desired lifecycle state again. This is key to preventing the backpressure leak of the AndroidX version, and it's also more analogous to the behavior of LiveData to which many developers are accustomed. There are two built-in ways to define a custom LifecycleCoroutineScope - by simply constructing one directly inside a Lifecycle class, or by statically setting a custom LifecycleScopeFactory . This second option can be very useful when utilizing an IdlingCoroutineScope . Testing \u00b6 Testing is why this library exists. TestCoroutineScope and TestCoroutineDispatcher are very powerful when they can be used, but any reference to a statically defined dispatcher (like a Dispatchers property) removes that control. To that end, there's a configurable TestDispatcherProvider : class TestDispatcherProvider ( override val default : CoroutineDispatcher = TestCoroutineDispatcher (), override val io : CoroutineDispatcher = TestCoroutineDispatcher (), override val main : CoroutineDispatcher = TestCoroutineDispatcher (), override val mainImmediate : CoroutineDispatcher = TestCoroutineDispatcher (), override val unconfined : CoroutineDispatcher = TestCoroutineDispatcher () ) : DispatcherProvider As well as a polymorphic TestProvidedCoroutineScope which may be used in place of any type-specific CoroutineScope : val testScope = TestProvidedCoroutineScope () val someUIClass = SomeUIClass ( testScope ) class SomeUIClass ( val coroutineScope : MainCoroutineScope ) { fun foo () = coroutineScope . launch { // ... } } There's also testProvided , which delegates to runBlockingTest but which includes a TestDispatcherProvider inside the TestCoroutineScope . class Subject { // this would normally be a hard-coded reference to Dispatchers.Main suspend fun sayHello () = withMain { } } @Test fun `sayHello should say hello` () = runBlockingProvided { val subject = SomeClass ( this ) // uses \"main\" TestCoroutineDispatcher safely with no additional setup subject . getSomeData () shouldPrint \"hello\" } Modules \u00b6 artifact features dispatch-android-espresso IdlingDispatcher IdlingDispatcherProvider dispatch-android-lifecycle-extensions dispatchLifecycleScope dispatch-android-lifecycle DispatchLifecycleScope launchOnCreate launchOnStart launchOnResume onNextCreate onNextStart onNextResume dispatch-android-viewmodel CoroutineViewModel viewModelScope dispatch-core Dispatcher-specific types and factories Dispatcher-specific coroutine builders dispatch-detekt Detekt rules for common auto-imported-the-wrong-thing problems dispatch-test-junit4 TestCoroutineRule dispatch-test-junit5 CoroutineTest CoroutineTestExtension dispatch-test TestProvidedCoroutineScope TestDispatcherProvider runBlockingProvided and testProvided Full Gradle Config \u00b6 repositories { mavenCentral () } dependencies { /* production code */ // core coroutines implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) // everything provides :core via \"api\", so you only need this if you have no other \"implementation\" dispatch artifacts implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) // LifecycleCoroutineScope for Android Fragments, Activities, etc. implementation ( \"com.rickbusarow.dispatch:dispatch-android-lifecycle:1.0.0-beta06\" ) // lifecycleScope extension function with a settable factory. Use this if you don't DI your CoroutineScopes // This provides :dispatch-android-lifecycle via \"api\", so you don't need to declare both implementation ( \"com.rickbusarow.dispatch:dispatch-android-lifecycle-extensions:1.0.0-beta06\" ) // ViewModelScope for Android ViewModels implementation ( \"com.rickbusarow.dispatch:dispatch-android-viewmodel:1.0.0-beta06\" ) /* jvm testing */ // core coroutines-test testImplementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.4.1\" ) // you only need this if you don't have the -junit4 or -junit5 artifacts testImplementation ( \"com.rickbusarow.dispatch:dispatch-test:1.0.0-beta06\" ) // CoroutineTestRule and :dispatch-test // This provides :dispatch-test via \"api\", so you don't need to declare both // This can be used at the same time as :dispatch-test-junit5 testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta06\" ) // CoroutineTest, CoroutineTestExtension, and :dispatch-test // This provides :dispatch-test via \"api\", so you don't need to declare both // This can be used at the same time as :dispatch-test-junit4 testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit5:1.0.0-beta06\" ) /* Android testing */ // core android androidTestImplementation ( \"androidx.test:runner:1.3.0\" ) androidTestImplementation ( \"androidx.test.espresso:espresso-core:3.3.0\" ) // IdlingDispatcher, IdlingDispatcherProvider, and IdlingCoroutineScope androidTestImplementation ( \"com.rickbusarow.dispatch:dispatch-android-espresso:1.0.0-beta06\" ) } License \u00b6 Copyright (C) 2020 Rick Busarow Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Intro"},{"location":"#dispatch","text":"Utilities for kotlinx.coroutines which make them type-safe, easier to test, and more expressive. Use the predefined types and factories or define your own, and never inject a Dispatchers object again. val presenter = MyPresenter ( MainCoroutineScope ()) class MyPresenter @Inject constructor ( /** * Defaults to the Main dispatcher */ val coroutineScope : MainCoroutineScope ) { fun loopSomething () = coroutineScope . launchDefault { } suspend fun updateSomething () = withMainImmediate { } } class MyTest { @Test fun `no setting the main dispatcher` () = runBlockingProvidedTest { // automatically use TestCoroutineDispatcher for every dispatcher type val presenter = MyPresenter ( coroutineScope = this ) // this call would normally crash due to the main looper presenter . updateSomething () } }","title":"Dispatch"},{"location":"#contents","text":"Injecting dispatchers Types and Factories Referencing dispatchers Builder Extensions Android Lifecycle Android Espresso Android ViewModel Testing Modules Full Gradle Config License","title":"Contents"},{"location":"#injecting-dispatchers","text":"Everywhere you use coroutines, you use a CoroutineContext . If we embed the CoroutineDispatchers settings we want into the context, then we don't need to pass them around manually. The core of this library is DispatcherProvider - an interface with properties corresponding to the 5 different CoroutineDispatchers we can get from the Dispatchers singleton. It lives inside the CoroutineContext , and gets passed from parent to child coroutines transparently without any additional code. interface DispatcherProvider : CoroutineContext . Element { override val key : CoroutineContext . Key <*> get () = Key val default : CoroutineDispatcher val io : CoroutineDispatcher val main : CoroutineDispatcher val mainImmediate : CoroutineDispatcher val unconfined : CoroutineDispatcher companion object Key : CoroutineContext . Key < DispatcherProvider > } val someCoroutineScope = CoroutineScope ( Job () + Dispatchers . Main + DispatcherProvider () ) The default implementation of this interface simply delegates to that Dispatchers singleton, as that is what we typically want for production usage.","title":"Injecting dispatchers"},{"location":"#types-and-factories","text":"A CoroutineScope may have any type of CoroutineDispatcher . What if we have a View class which will always use the Main thread, or one which will always do I/O? There are marker interfaces and factories to ensure that the correct type of CoroutineScope is always used. Type Dispatcher DefaultCoroutineScope Dispatchers.Default IOCoroutineScope Dispatchers.IO MainCoroutineScope Dispatchers.Main MainImmediateCoroutineScope Dispatchers.Main.immediate UnconfinedCoroutineScope Dispatchers.Unconfined val mainScope = MainCoroutineScope () val someUIClass = SomeUIClass ( mainScope ) class SomeUIClass ( val coroutineScope : MainCoroutineScope ) { fun foo () = coroutineScope . launch { // because of the dependency type, // we're guaranteed to be on the main dispatcher even though we didn't specify it } }","title":"Types and Factories"},{"location":"#referencing-dispatchers","text":"These dispatcher settings can then be accessed via extension functions upon CoroutineScope , or the coroutineContext , or directly from extension functions:","title":"Referencing dispatchers"},{"location":"#builder-extensions","text":"Default IO Main Main.immediate Unconfined Job launchDefault launchIO launchMain launchMainImmediate launchUnconfined Deferred asyncDefault asyncIO asyncMain asyncMainImmediate asyncUnconfined suspend T withDefault withIO withMain withMainImmediate withUnconfined Flow<T> flowOnDefault flowOnIO flowOnMain flowOnMainImmediate flowOnUnconfined class MyClass ( val coroutineScope : IOCoroutineScope ) { fun accessMainThread () = coroutineScope . launchMain { // we're now on the \"main\" thread as defined by the interface } }","title":"Builder Extensions"},{"location":"#android-lifecycle","text":"The AndroidX.lifecycle library offers a lifecycleScope extension function to provide a lifecycle-aware CoroutineScope , but there are two shortcomings: 1. It delegates to a hard-coded Dispatchers.Main CoroutineDispatcher , which complicates unit and Espresso testing by requiring the use of Dispatchers.setMain . 2. It pauses the dispatcher when the lifecycle state passes below its threshold, which leaks backpressure to the producing coroutine and can create deadlocks . Dispatch-android-lifecycle and dispatch-android-lifecycle-extensions completely replace the AndroidX version. import dispatch.android.lifecycle.* import dispatch.core.* import kotlinx.coroutines.flow.* class MyActivity : Activity () { init { dispatchLifecycleScope . launchOnCreate { viewModel . someFlow . collect { channel . send ( \"$it\" ) } } } } The DispatchLifecycleScope may be configured with any dispatcher, since MainImmediateCoroutineScope is just a marker interface. Its lifecycle-aware functions cancel when dropping below a threshold, then automatically restart when entering into the desired lifecycle state again. This is key to preventing the backpressure leak of the AndroidX version, and it's also more analogous to the behavior of LiveData to which many developers are accustomed. There are two built-in ways to define a custom LifecycleCoroutineScope - by simply constructing one directly inside a Lifecycle class, or by statically setting a custom LifecycleScopeFactory . This second option can be very useful when utilizing an IdlingCoroutineScope .","title":"Android Lifecycle"},{"location":"#android-espresso","text":"Espresso is able to use IdlingResource to infer when it should perform its actions, which helps to reduce the flakiness of tests. Conventional thread-based IdlingResource implementations don't work with coroutines, however. IdlingCoroutineScope utilizes IdlingDispatchers , which count a coroutine as being \"idle\" when it is suspended. Using statically defined factories, service locators, or dependency injection, it is possible to utilize idling-aware dispatchers throughout a codebase during Espresso testing. class IdlingCoroutineScopeRuleWithLifecycleSample { val customDispatcherProvider = IdlingDispatcherProvider () @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider ( customDispatcherProvider ) } /** * If you don't provide CoroutineScopes to your lifecycle components via a dependency injection framework, * you need to use the `dispatch-android-lifecycle-extensions` and `dispatch-android-viewmodel` artifacts * to ensure that the same `IdlingDispatcherProvider` is used. */ @Before fun setUp () { LifecycleScopeFactory . set { MainImmediateCoroutineScope ( customDispatcherProvider ) } ViewModelScopeFactory . set { MainImmediateCoroutineScope ( customDispatcherProvider ) } } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its \"idle\" state with Espresso } }","title":"Android Espresso"},{"location":"#android-viewmodel","text":"The AndroidX ViewModel library offers a viewModelScope extension function to provide an auto-cancelled CoroutineScope , but again, this CoroutineScope is hard-coded and uses Dispatchers.Main . This limitation needn't exist. Dispatch-android-viewmodel doesn't have as many options as its lifecycle counterpart, because the ViewModel.onCleared function is protected and ViewModel does not expose anything about its lifecycle. The only way for a third party library to achieve a lifecycle-aware CoroutineScope is through inheritance. CoroutineViewModel is a simple abstract class which exposes a lazy viewModelScope property which is automatically cancelled when the ViewModel is destroyed. The exact type of the viewModelScope can be configured statically via ViewModelScopeFactory . In this way, you can use IdlingCoroutineScopes for Espresso testing, TestProvidedCoroutineScopes for unit testing, or any other custom scope you'd like. If you're using the AAC ViewModel but not dependency injection, this artifact should be very helpful with testing. import dispatch.android.viewmodel.* import kotlinx.coroutines.flow.* import timber.log.* class MyViewModel : CoroutineViewModel () { init { MyRepository . someFlow . onEach { Timber . d ( \"$it\" ) }. launchIn ( viewModelScope ) } } The DispatchLifecycleScope may be configured with any dispatcher, since MainImmediateCoroutineScope is just a marker interface. Its lifecycle-aware functions cancel when dropping below a threshold, then automatically restart when entering into the desired lifecycle state again. This is key to preventing the backpressure leak of the AndroidX version, and it's also more analogous to the behavior of LiveData to which many developers are accustomed. There are two built-in ways to define a custom LifecycleCoroutineScope - by simply constructing one directly inside a Lifecycle class, or by statically setting a custom LifecycleScopeFactory . This second option can be very useful when utilizing an IdlingCoroutineScope .","title":"Android ViewModel"},{"location":"#testing","text":"Testing is why this library exists. TestCoroutineScope and TestCoroutineDispatcher are very powerful when they can be used, but any reference to a statically defined dispatcher (like a Dispatchers property) removes that control. To that end, there's a configurable TestDispatcherProvider : class TestDispatcherProvider ( override val default : CoroutineDispatcher = TestCoroutineDispatcher (), override val io : CoroutineDispatcher = TestCoroutineDispatcher (), override val main : CoroutineDispatcher = TestCoroutineDispatcher (), override val mainImmediate : CoroutineDispatcher = TestCoroutineDispatcher (), override val unconfined : CoroutineDispatcher = TestCoroutineDispatcher () ) : DispatcherProvider As well as a polymorphic TestProvidedCoroutineScope which may be used in place of any type-specific CoroutineScope : val testScope = TestProvidedCoroutineScope () val someUIClass = SomeUIClass ( testScope ) class SomeUIClass ( val coroutineScope : MainCoroutineScope ) { fun foo () = coroutineScope . launch { // ... } } There's also testProvided , which delegates to runBlockingTest but which includes a TestDispatcherProvider inside the TestCoroutineScope . class Subject { // this would normally be a hard-coded reference to Dispatchers.Main suspend fun sayHello () = withMain { } } @Test fun `sayHello should say hello` () = runBlockingProvided { val subject = SomeClass ( this ) // uses \"main\" TestCoroutineDispatcher safely with no additional setup subject . getSomeData () shouldPrint \"hello\" }","title":"Testing"},{"location":"#modules","text":"artifact features dispatch-android-espresso IdlingDispatcher IdlingDispatcherProvider dispatch-android-lifecycle-extensions dispatchLifecycleScope dispatch-android-lifecycle DispatchLifecycleScope launchOnCreate launchOnStart launchOnResume onNextCreate onNextStart onNextResume dispatch-android-viewmodel CoroutineViewModel viewModelScope dispatch-core Dispatcher-specific types and factories Dispatcher-specific coroutine builders dispatch-detekt Detekt rules for common auto-imported-the-wrong-thing problems dispatch-test-junit4 TestCoroutineRule dispatch-test-junit5 CoroutineTest CoroutineTestExtension dispatch-test TestProvidedCoroutineScope TestDispatcherProvider runBlockingProvided and testProvided","title":"Modules"},{"location":"#full-gradle-config","text":"repositories { mavenCentral () } dependencies { /* production code */ // core coroutines implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) // everything provides :core via \"api\", so you only need this if you have no other \"implementation\" dispatch artifacts implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) // LifecycleCoroutineScope for Android Fragments, Activities, etc. implementation ( \"com.rickbusarow.dispatch:dispatch-android-lifecycle:1.0.0-beta06\" ) // lifecycleScope extension function with a settable factory. Use this if you don't DI your CoroutineScopes // This provides :dispatch-android-lifecycle via \"api\", so you don't need to declare both implementation ( \"com.rickbusarow.dispatch:dispatch-android-lifecycle-extensions:1.0.0-beta06\" ) // ViewModelScope for Android ViewModels implementation ( \"com.rickbusarow.dispatch:dispatch-android-viewmodel:1.0.0-beta06\" ) /* jvm testing */ // core coroutines-test testImplementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.4.1\" ) // you only need this if you don't have the -junit4 or -junit5 artifacts testImplementation ( \"com.rickbusarow.dispatch:dispatch-test:1.0.0-beta06\" ) // CoroutineTestRule and :dispatch-test // This provides :dispatch-test via \"api\", so you don't need to declare both // This can be used at the same time as :dispatch-test-junit5 testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta06\" ) // CoroutineTest, CoroutineTestExtension, and :dispatch-test // This provides :dispatch-test via \"api\", so you don't need to declare both // This can be used at the same time as :dispatch-test-junit4 testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit5:1.0.0-beta06\" ) /* Android testing */ // core android androidTestImplementation ( \"androidx.test:runner:1.3.0\" ) androidTestImplementation ( \"androidx.test.espresso:espresso-core:3.3.0\" ) // IdlingDispatcher, IdlingDispatcherProvider, and IdlingCoroutineScope androidTestImplementation ( \"com.rickbusarow.dispatch:dispatch-android-espresso:1.0.0-beta06\" ) }","title":"Full Gradle Config"},{"location":"#license","text":"Copyright (C) 2020 Rick Busarow Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"CHANGELOG/","text":"Change log for Dispatch \u00b6 Version 1.0.0-beta06 \u00b6 Update to coroutines to 1.4.1 in order to fix an issue with SharedFlow ( #189 ) Version 1.0.0-beta05 \u00b6 Api changes \u00b6 ViewLifecycleCoroutineScope is a special DispatchLifecycleScope meant for binding a scope to a Fragment 's view lifecycle. ( #179 ) Make testProvided receive TestProvidedCoroutineScope ( #157 ) LifecycleCoroutineScope has been renamed to DispatchLifecycleScope , along with its extension function. The old names are still functional with a deprecated typealias. They will be removed in the future. ( #186 ) CoroutineViewModel has been renamed to DispatchViewModel . The old names are still functional with a deprecated typealias. They will be removed in the future. ( #186 ) Bug fixes \u00b6 Use currentCoroutineContext to resolve the inner CoroutineContext in flowOn___ functions. ( #181 ) Housekeeping \u00b6 Set the project JDK target to 8. This only affects the build environment since all previous builds were done on a JDK 8 machine. ( #187 ) Coroutines has been updated to 1.4.0 ( #183 ) Detekt has been updated to 1.4.2 ( #184 ) JUnit6 has been updated to 5.7.0 ( #178 ) Version 1.0.0-beta04 \u00b6 Features \u00b6 DefaultDispatcherProvider is now a mutable singleton which allows for a custom global default. Bug fixes \u00b6 dispatch-test-junit5 \u00b6 CoroutineTestExtension will now properly call Dispatchers.setMain(...) when injecting a CoroutineScope into a function or when not injecting at all. ( #130 ) dispatch-android-lifecycle \u00b6 LifecycleCoroutineScope will now be automatically cancelled when the associated Lifecycle drops to the Destroyed state. ( #135 ) dispatch-android-lifecycle-extensions \u00b6 Cached LifecycleCoroutineScopes will now be removed from the cache when they are destroyed. ( #136 ) Fixed a race condition where multiple LifecycleCoroutineScopes may be created for concurrent cache misses. ( #136 ) Deprecations \u00b6 The DefaultDispatcherProvider class constructor has been changed to an object factory function ( operator fun invoke(): DispatcherProvider ) and deprecated. This function will be removed prior to the 1.0 release. Breaking changes \u00b6 DefaultDispatcherProvider has been changed from a class to an object , and its functionality changed. It is now a singleton holder for a default DispatcherProvider instance. To create a default DispatcherProvider , use the interface's companion object factory function ( DispatcherProvider() ). Version 1.0.0-beta03 \u00b6 Renames \u00b6 The project has been renamed from DispatcherProvider to Dispatch. Maven coordinates for existing modules have changed. The base Maven coordinate has changed from com.rickbusarow.DispatcherProvider to com.rickbusarow.dispatch . Base package names have been updated. New artifacts \u00b6 dispatch-android-espresso adds support for IdlingResource dispatchers in Espresso testing. dispatch-android-lifecycle adds an alternative to the Androidx LifecycleScope functionality, with lots of configuration options. dispatch-android-lifecycle-extensions adds the lifecycleScope extension property, but with a configurable factory (useful for Espresso testing). dispatch-android-viewmodel adds an alternative to Androidx viewModelScope with configuration options. dispatch-detekt adds Detekt rules to warn against accidentally using a hard-coded CoroutineDispatcher. dispatch-test-junit4 adds a JUnit4 Rule for automatically providing and cleaning up a TestProvidedCoroutineScope . dispatch-test-junit5 adds JUnit5 Extension support for automatically providing and cleaning up a TestProvidedCoroutineScope . Version 1.0.0-beta02 \u00b6 Test features \u00b6 Added TestBasicDispatcherProvider factory which uses CommonPool for default and io , but a shared single-threaded ExecutorCoroutineDispatcher for main and mainImmediate to provide \"natural\" dispatch behavior in tests without Dispatchers.setMain(...) . Bug fixes and improvements \u00b6 runBlockingTestProvided now uses the same TestCoroutineDispatcher as its ContinuationInterceptor and in its TestDispatcherProvider (#15). runBlockingProvided now uses TestBasicDispatcherProvider as its DispatcherProvider . Version 1.0.0-beta01 \u00b6 Flow \u00b6 Add non-suspending flowOn___() operators for the Flow api. Misc \u00b6 Lots of Kdocs. Maven artifacts. Lower JDK version to 1.6","title":"Change Log"},{"location":"CHANGELOG/#change-log-for-dispatch","text":"","title":"Change log for Dispatch"},{"location":"CHANGELOG/#version-100-beta06","text":"Update to coroutines to 1.4.1 in order to fix an issue with SharedFlow ( #189 )","title":"Version 1.0.0-beta06"},{"location":"CHANGELOG/#version-100-beta05","text":"","title":"Version 1.0.0-beta05"},{"location":"CHANGELOG/#api-changes","text":"ViewLifecycleCoroutineScope is a special DispatchLifecycleScope meant for binding a scope to a Fragment 's view lifecycle. ( #179 ) Make testProvided receive TestProvidedCoroutineScope ( #157 ) LifecycleCoroutineScope has been renamed to DispatchLifecycleScope , along with its extension function. The old names are still functional with a deprecated typealias. They will be removed in the future. ( #186 ) CoroutineViewModel has been renamed to DispatchViewModel . The old names are still functional with a deprecated typealias. They will be removed in the future. ( #186 )","title":"Api changes"},{"location":"CHANGELOG/#bug-fixes","text":"Use currentCoroutineContext to resolve the inner CoroutineContext in flowOn___ functions. ( #181 )","title":"Bug fixes"},{"location":"CHANGELOG/#housekeeping","text":"Set the project JDK target to 8. This only affects the build environment since all previous builds were done on a JDK 8 machine. ( #187 ) Coroutines has been updated to 1.4.0 ( #183 ) Detekt has been updated to 1.4.2 ( #184 ) JUnit6 has been updated to 5.7.0 ( #178 )","title":"Housekeeping"},{"location":"CHANGELOG/#version-100-beta04","text":"","title":"Version 1.0.0-beta04"},{"location":"CHANGELOG/#features","text":"DefaultDispatcherProvider is now a mutable singleton which allows for a custom global default.","title":"Features"},{"location":"CHANGELOG/#bug-fixes_1","text":"","title":"Bug fixes"},{"location":"CHANGELOG/#dispatch-test-junit5","text":"CoroutineTestExtension will now properly call Dispatchers.setMain(...) when injecting a CoroutineScope into a function or when not injecting at all. ( #130 )","title":"dispatch-test-junit5"},{"location":"CHANGELOG/#dispatch-android-lifecycle","text":"LifecycleCoroutineScope will now be automatically cancelled when the associated Lifecycle drops to the Destroyed state. ( #135 )","title":"dispatch-android-lifecycle"},{"location":"CHANGELOG/#dispatch-android-lifecycle-extensions","text":"Cached LifecycleCoroutineScopes will now be removed from the cache when they are destroyed. ( #136 ) Fixed a race condition where multiple LifecycleCoroutineScopes may be created for concurrent cache misses. ( #136 )","title":"dispatch-android-lifecycle-extensions"},{"location":"CHANGELOG/#deprecations","text":"The DefaultDispatcherProvider class constructor has been changed to an object factory function ( operator fun invoke(): DispatcherProvider ) and deprecated. This function will be removed prior to the 1.0 release.","title":"Deprecations"},{"location":"CHANGELOG/#breaking-changes","text":"DefaultDispatcherProvider has been changed from a class to an object , and its functionality changed. It is now a singleton holder for a default DispatcherProvider instance. To create a default DispatcherProvider , use the interface's companion object factory function ( DispatcherProvider() ).","title":"Breaking changes"},{"location":"CHANGELOG/#version-100-beta03","text":"","title":"Version 1.0.0-beta03"},{"location":"CHANGELOG/#renames","text":"The project has been renamed from DispatcherProvider to Dispatch. Maven coordinates for existing modules have changed. The base Maven coordinate has changed from com.rickbusarow.DispatcherProvider to com.rickbusarow.dispatch . Base package names have been updated.","title":"Renames"},{"location":"CHANGELOG/#new-artifacts","text":"dispatch-android-espresso adds support for IdlingResource dispatchers in Espresso testing. dispatch-android-lifecycle adds an alternative to the Androidx LifecycleScope functionality, with lots of configuration options. dispatch-android-lifecycle-extensions adds the lifecycleScope extension property, but with a configurable factory (useful for Espresso testing). dispatch-android-viewmodel adds an alternative to Androidx viewModelScope with configuration options. dispatch-detekt adds Detekt rules to warn against accidentally using a hard-coded CoroutineDispatcher. dispatch-test-junit4 adds a JUnit4 Rule for automatically providing and cleaning up a TestProvidedCoroutineScope . dispatch-test-junit5 adds JUnit5 Extension support for automatically providing and cleaning up a TestProvidedCoroutineScope .","title":"New artifacts"},{"location":"CHANGELOG/#version-100-beta02","text":"","title":"Version 1.0.0-beta02"},{"location":"CHANGELOG/#test-features","text":"Added TestBasicDispatcherProvider factory which uses CommonPool for default and io , but a shared single-threaded ExecutorCoroutineDispatcher for main and mainImmediate to provide \"natural\" dispatch behavior in tests without Dispatchers.setMain(...) .","title":"Test features"},{"location":"CHANGELOG/#bug-fixes-and-improvements","text":"runBlockingTestProvided now uses the same TestCoroutineDispatcher as its ContinuationInterceptor and in its TestDispatcherProvider (#15). runBlockingProvided now uses TestBasicDispatcherProvider as its DispatcherProvider .","title":"Bug fixes and improvements"},{"location":"CHANGELOG/#version-100-beta01","text":"","title":"Version 1.0.0-beta01"},{"location":"CHANGELOG/#flow","text":"Add non-suspending flowOn___() operators for the Flow api.","title":"Flow"},{"location":"CHANGELOG/#misc","text":"Lots of Kdocs. Maven artifacts. Lower JDK version to 1.6","title":"Misc"},{"location":"dispatch-android-espresso/","text":"Module dispatch-android-espresso \u00b6 Tools to provide Espresso functionality for coroutines. If an IdlingDispatcherProvider is registered with the IdlingRegistry , Espresso will wait for all associated coroutines to leave the active state before performing any assertions. Coroutines which are in a suspended state (such as a Job \"observing\" a Flow for updates) do not prevent Espresso from performing assertions. class IdlingCoroutineScopeRuleWithLifecycleSample { // Retrieve the DispatcherProvider from a dependency graph, // so that the same one is used throughout the codebase. val customDispatcherProvider = testAppComponent . customDispatcherProvider @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider ( customDispatcherProvider ) } /** * If you don't provide CoroutineScopes to your lifecycle components via a dependency injection framework, * you need to use the `dispatch-android-lifecycle-extensions` and `dispatch-android-viewmodel` artifacts * to ensure that the same `IdlingDispatcherProvider` is used. */ @Before fun setUp () { LifecycleScopeFactory . set { MainImmediateCoroutineScope ( customDispatcherProvider ) } ViewModelScopeFactory . set { MainImmediateCoroutineScope ( customDispatcherProvider ) } } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its \"idle\" state with Espresso } } Contents \u00b6 Types IdlingCoroutineScopes Minimum Gradle Config Types \u00b6 Name Description IdlingDispatcherProviderRule JUnit 4 Rule which automatically registers an IdlingDispatcherProvider with the IdlingRegistry IdlingDispatcher A CoroutineDispatcher which tracks each dispatched coroutine using a CountingIdlingResource . All actual dispatches are delegated to a provided CoroutineDispatcher . IdlingDispatcherProvider A special DispatcherProvider which guarantees that each of its properties is an IdlingDispatcher IdlingCoroutineScope A special CoroutineScope which guarantees a property of an IdlingDispatcherProvider IdlingCoroutineScopes \u00b6 Marker Interface Factory Function Description DefaultIdlingCoroutineScope DefaultIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of default . IOIdlingCoroutineScope IOIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of io . MainIdlingCoroutineScope MainIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of main . MainImmediateIdlingCoroutineScope MainImmediateIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of mainImmediate . UnconfinedIdlingCoroutineScope UnconfinedIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of unconfined . Minimum Gradle Config \u00b6 Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { // core implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) androidTestImplementation ( \"com.rickbusarow.dispatch:dispatch-android-espresso:1.0.0-beta06\" ) // android androidTestImplementation ( \"androidx.test:runner:1.3.0\" ) androidTestImplementation ( \"androidx.test.espresso:espresso-core:3.3.0\" ) }","title":"android-espresso"},{"location":"dispatch-android-espresso/#module-dispatch-android-espresso","text":"Tools to provide Espresso functionality for coroutines. If an IdlingDispatcherProvider is registered with the IdlingRegistry , Espresso will wait for all associated coroutines to leave the active state before performing any assertions. Coroutines which are in a suspended state (such as a Job \"observing\" a Flow for updates) do not prevent Espresso from performing assertions. class IdlingCoroutineScopeRuleWithLifecycleSample { // Retrieve the DispatcherProvider from a dependency graph, // so that the same one is used throughout the codebase. val customDispatcherProvider = testAppComponent . customDispatcherProvider @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider ( customDispatcherProvider ) } /** * If you don't provide CoroutineScopes to your lifecycle components via a dependency injection framework, * you need to use the `dispatch-android-lifecycle-extensions` and `dispatch-android-viewmodel` artifacts * to ensure that the same `IdlingDispatcherProvider` is used. */ @Before fun setUp () { LifecycleScopeFactory . set { MainImmediateCoroutineScope ( customDispatcherProvider ) } ViewModelScopeFactory . set { MainImmediateCoroutineScope ( customDispatcherProvider ) } } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its \"idle\" state with Espresso } }","title":"Module dispatch-android-espresso"},{"location":"dispatch-android-espresso/#contents","text":"Types IdlingCoroutineScopes Minimum Gradle Config","title":"Contents"},{"location":"dispatch-android-espresso/#types","text":"Name Description IdlingDispatcherProviderRule JUnit 4 Rule which automatically registers an IdlingDispatcherProvider with the IdlingRegistry IdlingDispatcher A CoroutineDispatcher which tracks each dispatched coroutine using a CountingIdlingResource . All actual dispatches are delegated to a provided CoroutineDispatcher . IdlingDispatcherProvider A special DispatcherProvider which guarantees that each of its properties is an IdlingDispatcher IdlingCoroutineScope A special CoroutineScope which guarantees a property of an IdlingDispatcherProvider","title":"Types"},{"location":"dispatch-android-espresso/#idlingcoroutinescopes","text":"Marker Interface Factory Function Description DefaultIdlingCoroutineScope DefaultIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of default . IOIdlingCoroutineScope IOIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of io . MainIdlingCoroutineScope MainIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of main . MainImmediateIdlingCoroutineScope MainImmediateIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of mainImmediate . UnconfinedIdlingCoroutineScope UnconfinedIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of unconfined .","title":"IdlingCoroutineScopes"},{"location":"dispatch-android-espresso/#minimum-gradle-config","text":"Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { // core implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) androidTestImplementation ( \"com.rickbusarow.dispatch:dispatch-android-espresso:1.0.0-beta06\" ) // android androidTestImplementation ( \"androidx.test:runner:1.3.0\" ) androidTestImplementation ( \"androidx.test.espresso:espresso-core:3.3.0\" ) }","title":"Minimum Gradle Config"},{"location":"dispatch-android-lifecycle-extensions/","text":"Module dispatch-android-lifecycle-extensions \u00b6 Contents \u00b6 Api One-time suspend functions Difference from AndroidX Custom CoroutineScope factories Automatic lifecycle jobs Minimum Gradle Config Api \u00b6 One-time suspend functions \u00b6 Examples import dispatch.android.* // This could be any LifecycleOwner -- Fragments, Activities, Services... class SomeScreen : Fragment () { init { // auto-created MainImmediateCoroutineScope which is lifecycle-aware dispatchLifecycleScope //... // active only when \"resumed\". starts a fresh coroutine each time // this is a rough proxy for LiveData behavior dispatchLifecycleScope . launchEveryResume { } // active only when \"started\". starts a fresh coroutine each time dispatchLifecycleScope . launchEveryStart { } // launch when created, automatically stop on destroy dispatchLifecycleScope . launchEveryCreate { } // it works as a normal CoroutineScope as well (because it is) dispatchLifecycleScope . launchMain { } } } class SomeApplication : Application () { override fun onCreate () { super . onCreate () // A custom factory can be set to add elements to the CoroutineContext LifecycleScopeFactory . set { MainImmediateContext () + SomeCustomElement () } } } class SomeEspressoTest { @Before fun setUp () { // This custom factory can be used to use custom scopes for testing, // such as an idling dispatcher LifecycleScopeFactory . set { MainImmediateIdlingCoroutineScope (). coroutineContext } } @After fun tearDown () { // The factory can also be reset to default LifecycleScopeFactory . reset () } } Difference from AndroidX \u00b6 This module is really just a slightly different version of androidx-lifecycle-runtime-ktx \u2014 the library which gives us the lifecycleScope property. Why not just use AndroidX? Because we need two things it doesn't offer. Custom CoroutineScope factories \u00b6 The way androidx-lifecycle-runtime constructs its CoroutineScope is hard-coded , which eliminates the possibility of using a custom CoroutineContext such as a DispatcherProvider or IdlingDispatcher . With dispatch.android.lifecycle , we can set a custom factory. class SomeFragmentEspressoTest { // Not part of this artifact. see dispatch-android-espresso @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule () @Before fun setUp () { // set a custom factory which is applied to all newly created lifecycleScopes LifecycleScopeFactory . set { MainImmediateContext () + idlingRule . dispatcherProvider } // now SomeFragment will use an IdlingDispatcher in its CoroutineScope } } Automatic lifecycle jobs \u00b6 Structured concurrency relies upon cancellation, but androidx-lifecycle-runtime.ktx doesn't cancel. It uses a special PausingDispatcher . This pausing behavior then leaks upstream, creating backpressure and potentially deadlocks. There's a bug filed in their issue tracker , but 2.2.0 got released anyway. This library's API surface is the same as that within the AndroidX version, but has a different strategy for handling lifecycle events. When a lifecycle state enters the desired range, such as at ON_RESUME , a new coroutine is created. When the state exists the range, that coroutine is cancelled . If the lifecycle state enters the desired range again, a new coroutine is created. import dispatch.android.* class SomeFragment : Fragment () { val viewModel : SomeViewModel by viewModels () init { // automatically created CoroutineScope using the factory described above dispatchLifecycleScope . launchWhenResumed { viewModel . someFlow . consume { } } } } This has the desired effect of not leaking backpressure upstream (which in this example is the viewModel ). Minimum Gradle Config \u00b6 Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-android-lifecycle-extensions:1.0.0-beta06\" ) implementation ( \"androidx.lifecycle:lifecycle-common:2.2.0\" ) }","title":"android-lifecycle-extensions"},{"location":"dispatch-android-lifecycle-extensions/#module-dispatch-android-lifecycle-extensions","text":"","title":"Module dispatch-android-lifecycle-extensions"},{"location":"dispatch-android-lifecycle-extensions/#contents","text":"Api One-time suspend functions Difference from AndroidX Custom CoroutineScope factories Automatic lifecycle jobs Minimum Gradle Config","title":"Contents"},{"location":"dispatch-android-lifecycle-extensions/#api","text":"","title":"Api"},{"location":"dispatch-android-lifecycle-extensions/#one-time-suspend-functions","text":"Examples import dispatch.android.* // This could be any LifecycleOwner -- Fragments, Activities, Services... class SomeScreen : Fragment () { init { // auto-created MainImmediateCoroutineScope which is lifecycle-aware dispatchLifecycleScope //... // active only when \"resumed\". starts a fresh coroutine each time // this is a rough proxy for LiveData behavior dispatchLifecycleScope . launchEveryResume { } // active only when \"started\". starts a fresh coroutine each time dispatchLifecycleScope . launchEveryStart { } // launch when created, automatically stop on destroy dispatchLifecycleScope . launchEveryCreate { } // it works as a normal CoroutineScope as well (because it is) dispatchLifecycleScope . launchMain { } } } class SomeApplication : Application () { override fun onCreate () { super . onCreate () // A custom factory can be set to add elements to the CoroutineContext LifecycleScopeFactory . set { MainImmediateContext () + SomeCustomElement () } } } class SomeEspressoTest { @Before fun setUp () { // This custom factory can be used to use custom scopes for testing, // such as an idling dispatcher LifecycleScopeFactory . set { MainImmediateIdlingCoroutineScope (). coroutineContext } } @After fun tearDown () { // The factory can also be reset to default LifecycleScopeFactory . reset () } }","title":"One-time suspend functions"},{"location":"dispatch-android-lifecycle-extensions/#difference-from-androidx","text":"This module is really just a slightly different version of androidx-lifecycle-runtime-ktx \u2014 the library which gives us the lifecycleScope property. Why not just use AndroidX? Because we need two things it doesn't offer.","title":"Difference from AndroidX"},{"location":"dispatch-android-lifecycle-extensions/#custom-coroutinescope-factories","text":"The way androidx-lifecycle-runtime constructs its CoroutineScope is hard-coded , which eliminates the possibility of using a custom CoroutineContext such as a DispatcherProvider or IdlingDispatcher . With dispatch.android.lifecycle , we can set a custom factory. class SomeFragmentEspressoTest { // Not part of this artifact. see dispatch-android-espresso @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule () @Before fun setUp () { // set a custom factory which is applied to all newly created lifecycleScopes LifecycleScopeFactory . set { MainImmediateContext () + idlingRule . dispatcherProvider } // now SomeFragment will use an IdlingDispatcher in its CoroutineScope } }","title":"Custom CoroutineScope factories"},{"location":"dispatch-android-lifecycle-extensions/#automatic-lifecycle-jobs","text":"Structured concurrency relies upon cancellation, but androidx-lifecycle-runtime.ktx doesn't cancel. It uses a special PausingDispatcher . This pausing behavior then leaks upstream, creating backpressure and potentially deadlocks. There's a bug filed in their issue tracker , but 2.2.0 got released anyway. This library's API surface is the same as that within the AndroidX version, but has a different strategy for handling lifecycle events. When a lifecycle state enters the desired range, such as at ON_RESUME , a new coroutine is created. When the state exists the range, that coroutine is cancelled . If the lifecycle state enters the desired range again, a new coroutine is created. import dispatch.android.* class SomeFragment : Fragment () { val viewModel : SomeViewModel by viewModels () init { // automatically created CoroutineScope using the factory described above dispatchLifecycleScope . launchWhenResumed { viewModel . someFlow . consume { } } } } This has the desired effect of not leaking backpressure upstream (which in this example is the viewModel ).","title":"Automatic lifecycle jobs"},{"location":"dispatch-android-lifecycle-extensions/#minimum-gradle-config","text":"Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-android-lifecycle-extensions:1.0.0-beta06\" ) implementation ( \"androidx.lifecycle:lifecycle-common:2.2.0\" ) }","title":"Minimum Gradle Config"},{"location":"dispatch-android-lifecycle/","text":"Module dispatch-android-lifecycle \u00b6 CoroutineScope functionality linked with an Android Lifecycle . Contents \u00b6 Types Member functions Extension functions Minimum Gradle Config Types \u00b6 Name Description DispatchLifecycleScope MainCoroutineScope with a Lifecycle , capable of automatically cancelling and restarting coroutines along with that lifecycle. MinimumStatePolicy Defines the behavior of a Lifecycle -aware Job when it passes below its minimum Lifecycle.State Member functions \u00b6 Name Description launchOnCreate Creates a coroutine tied to a Lifecycle which will automatically enact a MinimumStatePolicy upon dropping below Lifecycle.State.CREATED launchOnStart Creates a coroutine tied to a Lifecycle which will automatically enact a MinimumStatePolicy upon dropping below Lifecycle.State.STARTED launchOnResume Creates a coroutine tied to a Lifecycle which will automatically enact a MinimumStatePolicy upon dropping below Lifecycle.State.RESUMED Extension functions \u00b6 LifecycleOwner extension suspending functions: Name Description onNextCreate Executes code one time upon reaching a state of Lifecycle.State.CREATED onNextStart Executes code one time upon reaching a state of Lifecycle.State.STARTED onNextResume Executes code one time upon reaching a state of Lifecycle.State.RESUMED Lifecycle extension suspending functions: Name Description onNextCreate Executes code one time upon reaching a state of Lifecycle.State.CREATED onNextStart Executes code one time upon reaching a state of Lifecycle.State.STARTED onNextResume Executes code one time upon reaching a state of Lifecycle.State.RESUMED Minimum Gradle Config \u00b6 Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-android-lifecycle:1.0.0-beta06\" ) implementation ( \"androidx.lifecycle:lifecycle-common:2.2.0\" ) }","title":"android-lifecycle"},{"location":"dispatch-android-lifecycle/#module-dispatch-android-lifecycle","text":"CoroutineScope functionality linked with an Android Lifecycle .","title":"Module dispatch-android-lifecycle"},{"location":"dispatch-android-lifecycle/#contents","text":"Types Member functions Extension functions Minimum Gradle Config","title":"Contents"},{"location":"dispatch-android-lifecycle/#types","text":"Name Description DispatchLifecycleScope MainCoroutineScope with a Lifecycle , capable of automatically cancelling and restarting coroutines along with that lifecycle. MinimumStatePolicy Defines the behavior of a Lifecycle -aware Job when it passes below its minimum Lifecycle.State","title":"Types"},{"location":"dispatch-android-lifecycle/#member-functions","text":"Name Description launchOnCreate Creates a coroutine tied to a Lifecycle which will automatically enact a MinimumStatePolicy upon dropping below Lifecycle.State.CREATED launchOnStart Creates a coroutine tied to a Lifecycle which will automatically enact a MinimumStatePolicy upon dropping below Lifecycle.State.STARTED launchOnResume Creates a coroutine tied to a Lifecycle which will automatically enact a MinimumStatePolicy upon dropping below Lifecycle.State.RESUMED","title":"Member functions"},{"location":"dispatch-android-lifecycle/#extension-functions","text":"LifecycleOwner extension suspending functions: Name Description onNextCreate Executes code one time upon reaching a state of Lifecycle.State.CREATED onNextStart Executes code one time upon reaching a state of Lifecycle.State.STARTED onNextResume Executes code one time upon reaching a state of Lifecycle.State.RESUMED Lifecycle extension suspending functions: Name Description onNextCreate Executes code one time upon reaching a state of Lifecycle.State.CREATED onNextStart Executes code one time upon reaching a state of Lifecycle.State.STARTED onNextResume Executes code one time upon reaching a state of Lifecycle.State.RESUMED","title":"Extension functions"},{"location":"dispatch-android-lifecycle/#minimum-gradle-config","text":"Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-android-lifecycle:1.0.0-beta06\" ) implementation ( \"androidx.lifecycle:lifecycle-common:2.2.0\" ) }","title":"Minimum Gradle Config"},{"location":"dispatch-android-viewmodel/","text":"Module dispatch-android-viewmodel \u00b6 The artifact I hope you don't need, but if you're not doing dependency injection, you probably do. Contents \u00b6 Examples Difference from AndroidX Custom CoroutineScope factories Automatic cancellation in onCleared() viewModelScope is not lifecycleScope Extending ViewModel Minimum Gradle Config Examples \u00b6 import dispatch.android.* // DispatchViewModel is just a ViewModel with a lazy viewModelScope class SomeViewModel : DispatchViewModel () { // ... init { // auto-creates a MainImmediateCoroutineScope which is closed in onCleared() viewModelScope . //... // multiple invocations use the same instance viewModelScope . launch { } // it works as a normal CoroutineScope (because it is) viewModelScope . launchMain { } } } class SomeApplication : Application () { override fun onCreate () { super . onCreate () // A custom factory can be set to add elements to the CoroutineContext ViewModelScopeFactory . set { MainImmediateCoroutineScope () + SomeCustomElement () } } } class SomeViewModelTest { val viewModel = SomeViewModel () @Before fun setUp () { // This custom factory can be used to use custom scopes for testing ViewModelScopeFactory . set { TestProvidedCoroutineScope () } } @After fun tearDown () { // The factory can also be reset to default ViewModelScopeFactory . reset () } @Test fun someTest () = runBlocking { // the AndroidX version is public, so it's public here as well. viewModel . viewModelScope . launch { } } } Difference from AndroidX \u00b6 This module is essentially a fork of androidx-lifecycle-viewmodel-ktx \u2014 the library which gives us the viewModelScope property. It exists entirely so that we can have a settable factory. This gives us a lot more options for JVM or instrumented tests, with custom dispatchers or other custom CoroutineContext elements. Custom CoroutineScope factories \u00b6 The way androidx-lifecycle-viewModel constructs its CoroutineScope is hard-coded , which eliminates the possibility of using a custom CoroutineContext such as a DispatcherProvider or IdlingDispatcher . With dispatch-android-lifecycle , we can set a custom factory. class SomeViewModelTest { @Before fun setUp () { // This custom factory can be used to use custom scopes for testing ViewModelScopeFactory . set { TestProvidedCoroutineScope () } // it could also return a specific instance val someTestScope = TestProvidedCoroutineScope () ViewModelScopeFactory . set { someTestScope } } @After fun tearDown () { // The factory can also be reset to default ViewModelScopeFactory . reset () } } Automatic cancellation in onCleared() \u00b6 Just like AndroidX, this version of viewModelScope is automatically cancelled in ViewModel.onCleared() . viewModelScope is not lifecycleScope \u00b6 It's important to remember that onCleared() is only called when a ViewModel is about to be destroyed -- when its associated LifecycleOwner (s) are all destroyed. This means that a viewModelScope is active while the LifecycleOwner is in the backstack. Consider this example: // Don't do this class SomeViewModel : DispatchViewModel () { init { viewModelScope . launch { // this job will continue forever even if the ViewModel is on the backstack. someRepository . dataFlow . collect { parseData ( it ) } } } } A CoroutineScope in a ViewModel is better utilized for single-shot requests which shouldn't be restarted in the event of a configuration change. \"Observer\" behavior should be scoped to the associated view. // Maybe do this class SomeFragment : Fragment () { val viewModel : SomeViewModel by viewModels () init { lifecycleScope . launchWhenResumed { viewModel . dataFlow . collect { } } } } class SomeViewModel : DispatchViewModel () { // a single shot request is made using the viewModelScope val lazyData by lazy { CompletableDeferred < Data >(). apply { viewModelScope . launch { complete ( someRepository . getData ()) } } } // collection of the Flow is done using the view's lifecycleScope, // meaning that it will stop as soon as the screen is in the backstack val dataFlow = someRepository . dataFlow . onEach { parseData ( it ) } } Extending ViewModel \u00b6 Since nothing about the clear event is actually exposed outside of ViewModel , it's necessary to extend ViewModel in order to consume it for cancelling the viewModelScope . This is especially galling since ViewModel could absolutely have just been an interface to begin with. Minimum Gradle Config \u00b6 Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-android-viewmodel:1.0.0-beta06\" ) }","title":"android-viewmodel"},{"location":"dispatch-android-viewmodel/#module-dispatch-android-viewmodel","text":"The artifact I hope you don't need, but if you're not doing dependency injection, you probably do.","title":"Module dispatch-android-viewmodel"},{"location":"dispatch-android-viewmodel/#contents","text":"Examples Difference from AndroidX Custom CoroutineScope factories Automatic cancellation in onCleared() viewModelScope is not lifecycleScope Extending ViewModel Minimum Gradle Config","title":"Contents"},{"location":"dispatch-android-viewmodel/#examples","text":"import dispatch.android.* // DispatchViewModel is just a ViewModel with a lazy viewModelScope class SomeViewModel : DispatchViewModel () { // ... init { // auto-creates a MainImmediateCoroutineScope which is closed in onCleared() viewModelScope . //... // multiple invocations use the same instance viewModelScope . launch { } // it works as a normal CoroutineScope (because it is) viewModelScope . launchMain { } } } class SomeApplication : Application () { override fun onCreate () { super . onCreate () // A custom factory can be set to add elements to the CoroutineContext ViewModelScopeFactory . set { MainImmediateCoroutineScope () + SomeCustomElement () } } } class SomeViewModelTest { val viewModel = SomeViewModel () @Before fun setUp () { // This custom factory can be used to use custom scopes for testing ViewModelScopeFactory . set { TestProvidedCoroutineScope () } } @After fun tearDown () { // The factory can also be reset to default ViewModelScopeFactory . reset () } @Test fun someTest () = runBlocking { // the AndroidX version is public, so it's public here as well. viewModel . viewModelScope . launch { } } }","title":"Examples"},{"location":"dispatch-android-viewmodel/#difference-from-androidx","text":"This module is essentially a fork of androidx-lifecycle-viewmodel-ktx \u2014 the library which gives us the viewModelScope property. It exists entirely so that we can have a settable factory. This gives us a lot more options for JVM or instrumented tests, with custom dispatchers or other custom CoroutineContext elements.","title":"Difference from AndroidX"},{"location":"dispatch-android-viewmodel/#custom-coroutinescope-factories","text":"The way androidx-lifecycle-viewModel constructs its CoroutineScope is hard-coded , which eliminates the possibility of using a custom CoroutineContext such as a DispatcherProvider or IdlingDispatcher . With dispatch-android-lifecycle , we can set a custom factory. class SomeViewModelTest { @Before fun setUp () { // This custom factory can be used to use custom scopes for testing ViewModelScopeFactory . set { TestProvidedCoroutineScope () } // it could also return a specific instance val someTestScope = TestProvidedCoroutineScope () ViewModelScopeFactory . set { someTestScope } } @After fun tearDown () { // The factory can also be reset to default ViewModelScopeFactory . reset () } }","title":"Custom CoroutineScope factories"},{"location":"dispatch-android-viewmodel/#automatic-cancellation-in-oncleared","text":"Just like AndroidX, this version of viewModelScope is automatically cancelled in ViewModel.onCleared() .","title":"Automatic cancellation in onCleared()"},{"location":"dispatch-android-viewmodel/#viewmodelscope-is-not-lifecyclescope","text":"It's important to remember that onCleared() is only called when a ViewModel is about to be destroyed -- when its associated LifecycleOwner (s) are all destroyed. This means that a viewModelScope is active while the LifecycleOwner is in the backstack. Consider this example: // Don't do this class SomeViewModel : DispatchViewModel () { init { viewModelScope . launch { // this job will continue forever even if the ViewModel is on the backstack. someRepository . dataFlow . collect { parseData ( it ) } } } } A CoroutineScope in a ViewModel is better utilized for single-shot requests which shouldn't be restarted in the event of a configuration change. \"Observer\" behavior should be scoped to the associated view. // Maybe do this class SomeFragment : Fragment () { val viewModel : SomeViewModel by viewModels () init { lifecycleScope . launchWhenResumed { viewModel . dataFlow . collect { } } } } class SomeViewModel : DispatchViewModel () { // a single shot request is made using the viewModelScope val lazyData by lazy { CompletableDeferred < Data >(). apply { viewModelScope . launch { complete ( someRepository . getData ()) } } } // collection of the Flow is done using the view's lifecycleScope, // meaning that it will stop as soon as the screen is in the backstack val dataFlow = someRepository . dataFlow . onEach { parseData ( it ) } }","title":"viewModelScope is not lifecycleScope"},{"location":"dispatch-android-viewmodel/#extending-viewmodel","text":"Since nothing about the clear event is actually exposed outside of ViewModel , it's necessary to extend ViewModel in order to consume it for cancelling the viewModelScope . This is especially galling since ViewModel could absolutely have just been an interface to begin with.","title":"Extending ViewModel"},{"location":"dispatch-android-viewmodel/#minimum-gradle-config","text":"Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-android-viewmodel:1.0.0-beta06\" ) }","title":"Minimum Gradle Config"},{"location":"dispatch-core/","text":"Module dispatch-core \u00b6 Never reference Dispatchers again, and never inject a dispatchers interface into your classes. All the standard CoroutineDispatcher types are embedded in a CoroutineContext and can be accessed explicitly or via convenient extension functions . fun foo ( scope : CoroutineScope ) { scope . launchDefault { } scope . launchIO { } scope . launchMain { } scope . launchMainImmediate { } scope . launchUnconfined { } } You can define custom mappings via a factory , making testing much easier, or use the default, which simply maps to Dispatchers . // a standard DispatcherProvider is easy to create val myDefaultDispatchProvider = DispatcherProvider () // but they're also very extensible. This version is interchangeable and is convenient in some test scenarios. val myCustomDispatcherProvider = object : DispatcherProvider { override val default : CoroutineDispatcher = newSingleThreadCoroutineContext ( \"default\" ) override val io : CoroutineDispatcher = newSingleThreadCoroutineContext ( \"io\" ) override val main : CoroutineDispatcher get () = newSingleThreadCoroutineContext ( \"main\" ) override val mainImmediate : CoroutineDispatcher get () = newSingleThreadCoroutineContext ( \"mainImmediate\" ) override val unconfined : CoroutineDispatcher = newSingleThreadCoroutineContext ( \"unconfined\" ) } Custom CoroutineScopes interfaces allow for more granularity when defining a class or function with a CoroutineScope dependency. There are also factory functions for conveniently creating any implementation, with a built-in DispatcherProvider . val mainScope = MainCoroutineScope () val someUIClass = SomeUIClass ( mainScope ) class SomeUIClass ( val coroutineScope : MainCoroutineScope ) { fun foo () = coroutineScope . launch { // ... } } Contents \u00b6 Types Marker interfaces and factories Extensions Launch Async WithContext Flow DefaultDispatcherProvider Out-of-box default functionality Easy global dispatcher overrides Minimum Gradle Config Types \u00b6 Name Description DispatcherProvider Interface which provides the 5 standard CoroutineDispatcher properties of the Dispatchers object, but which can be embedded in a CoroutineContext DefaultDispatcherProvider Mutable singleton holder for an implementation of DispatcherProvider . By default, it simply delegates to the corresponding properties in the Dispatchers singleton. Whenever a CoroutineContext does not have a DispatcherProvider , this singleton's value will be used by default. Marker interfaces and factories \u00b6 Name Dispatcher DefaultCoroutineScope DispatcherProvider.default IOCoroutineScope DispatcherProvider.io MainCoroutineScope DispatcherProvider.main MainImmediateCoroutineScope DispatcherProvider.mainImmediate UnconfinedCoroutineScope DispatcherProvider.unconfined Extensions \u00b6 Default IO Main Main.immediate Unconfined Job launchDefault launchIO launchMain launchMainImmediate launchUnconfined Deferred asyncDefault asyncIO asyncMain asyncMainImmediate asyncUnconfined suspend T withDefault withIO withMain withMainImmediate withUnconfined Flow<T> flowOnDefault flowOnIO flowOnMain flowOnMainImmediate flowOnUnconfined Launch \u00b6 fun foo ( scope : CoroutineScope ) { scope . launchDefault { } scope . launchIO { } scope . launchMain { } scope . launchMainImmediate { } scope . launchUnconfined { } } Async \u00b6 fun foo ( scope : CoroutineScope ) { scope . asyncDefault { } scope . asyncIO { } scope . asyncMain { } scope . asyncMainImmediate { } scope . asyncUnconfined { } } WithContext \u00b6 The CoroutineContext used for withContext comes from the coroutineContext top-level suspend property in kotlin.coroutines . It returns the current context, so the default , io , etc. used here are the ones defined in the CoroutineScope of the caller. There is no need to inject any other dependencies. suspend fun foo () { // note that we have no CoroutineContext withDefault { } withIO { } withMain { } withMainImmediate { } withUnconfined { } } Flow \u00b6 Like withContext , Flow typically doesn\u2019t get a CoroutineScope of its own. They inherit the coroutineContext from the collector in a pattern called context preservation . These new operators maintain context preservation ( they\u2019re forced to, actually ), and extract the coroutineContext from the collector. val someFlow = flow { } . flowOnDefault () . flowOnIO () . flowOnMain () . flowOnMainImmediate () . flowOnUnconfined () DefaultDispatcherProvider \u00b6 The simplest way to get up and running with Dispatch. All library access to a CoroutineContext's DispatcherProvider filters through a single extension property: public val CoroutineContext . dispatcherProvider : DispatcherProvider get () = get ( DispatcherProvider ) ?: DefaultDispatcherProvider . get () If the receiver does not have a DispatcherProvider , the value from DefaultDispatcherProvider will be returned. In practice, this brings at least two benefits: Out-of-box default functionality \u00b6 Calls such as launchIO { ... } or withMain { ... } are safe to use (guaranteed to have a DispatcherProvider ) regardless of the source of the CoroutineContext or CoroutineScope and without any additional configuration. By default, they will access the corresponding CoroutineDispatchers from the Dispatchers singleton. Easy global dispatcher overrides \u00b6 DefaultDispatcherProvider has similar set / reset functionality to the Dispatchers.setMain / Dispatchers.resetMain extensions in kotlinx-coroutines-test , except it doesn't need to be confined to testing. You can use DefaultDispatcherProvider.set to globally set a custom implementation at the beginning of an application's lifecycle, but the most likely use-case is certainly in testing. @Test fun `my test` () = runBlocking { DefaultDispatcherProvider . set ( TestDispatcherProvider ()) withMain { // this would normally crash without using Dispatchers.setMain // but \"main\" here comes from the TestDispatcherProvider created above -- not Dispatchers.Main } DefaultDispatcherProvider . reset () // from dispatch-test } See dispatch-test and TestDispatcherProvider Minimum Gradle Config \u00b6 Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) }","title":"core"},{"location":"dispatch-core/#module-dispatch-core","text":"Never reference Dispatchers again, and never inject a dispatchers interface into your classes. All the standard CoroutineDispatcher types are embedded in a CoroutineContext and can be accessed explicitly or via convenient extension functions . fun foo ( scope : CoroutineScope ) { scope . launchDefault { } scope . launchIO { } scope . launchMain { } scope . launchMainImmediate { } scope . launchUnconfined { } } You can define custom mappings via a factory , making testing much easier, or use the default, which simply maps to Dispatchers . // a standard DispatcherProvider is easy to create val myDefaultDispatchProvider = DispatcherProvider () // but they're also very extensible. This version is interchangeable and is convenient in some test scenarios. val myCustomDispatcherProvider = object : DispatcherProvider { override val default : CoroutineDispatcher = newSingleThreadCoroutineContext ( \"default\" ) override val io : CoroutineDispatcher = newSingleThreadCoroutineContext ( \"io\" ) override val main : CoroutineDispatcher get () = newSingleThreadCoroutineContext ( \"main\" ) override val mainImmediate : CoroutineDispatcher get () = newSingleThreadCoroutineContext ( \"mainImmediate\" ) override val unconfined : CoroutineDispatcher = newSingleThreadCoroutineContext ( \"unconfined\" ) } Custom CoroutineScopes interfaces allow for more granularity when defining a class or function with a CoroutineScope dependency. There are also factory functions for conveniently creating any implementation, with a built-in DispatcherProvider . val mainScope = MainCoroutineScope () val someUIClass = SomeUIClass ( mainScope ) class SomeUIClass ( val coroutineScope : MainCoroutineScope ) { fun foo () = coroutineScope . launch { // ... } }","title":"Module dispatch-core"},{"location":"dispatch-core/#contents","text":"Types Marker interfaces and factories Extensions Launch Async WithContext Flow DefaultDispatcherProvider Out-of-box default functionality Easy global dispatcher overrides Minimum Gradle Config","title":"Contents"},{"location":"dispatch-core/#types","text":"Name Description DispatcherProvider Interface which provides the 5 standard CoroutineDispatcher properties of the Dispatchers object, but which can be embedded in a CoroutineContext DefaultDispatcherProvider Mutable singleton holder for an implementation of DispatcherProvider . By default, it simply delegates to the corresponding properties in the Dispatchers singleton. Whenever a CoroutineContext does not have a DispatcherProvider , this singleton's value will be used by default.","title":"Types"},{"location":"dispatch-core/#marker-interfaces-and-factories","text":"Name Dispatcher DefaultCoroutineScope DispatcherProvider.default IOCoroutineScope DispatcherProvider.io MainCoroutineScope DispatcherProvider.main MainImmediateCoroutineScope DispatcherProvider.mainImmediate UnconfinedCoroutineScope DispatcherProvider.unconfined","title":"Marker interfaces and factories"},{"location":"dispatch-core/#extensions","text":"Default IO Main Main.immediate Unconfined Job launchDefault launchIO launchMain launchMainImmediate launchUnconfined Deferred asyncDefault asyncIO asyncMain asyncMainImmediate asyncUnconfined suspend T withDefault withIO withMain withMainImmediate withUnconfined Flow<T> flowOnDefault flowOnIO flowOnMain flowOnMainImmediate flowOnUnconfined","title":"Extensions"},{"location":"dispatch-core/#launch","text":"fun foo ( scope : CoroutineScope ) { scope . launchDefault { } scope . launchIO { } scope . launchMain { } scope . launchMainImmediate { } scope . launchUnconfined { } }","title":"Launch"},{"location":"dispatch-core/#async","text":"fun foo ( scope : CoroutineScope ) { scope . asyncDefault { } scope . asyncIO { } scope . asyncMain { } scope . asyncMainImmediate { } scope . asyncUnconfined { } }","title":"Async"},{"location":"dispatch-core/#withcontext","text":"The CoroutineContext used for withContext comes from the coroutineContext top-level suspend property in kotlin.coroutines . It returns the current context, so the default , io , etc. used here are the ones defined in the CoroutineScope of the caller. There is no need to inject any other dependencies. suspend fun foo () { // note that we have no CoroutineContext withDefault { } withIO { } withMain { } withMainImmediate { } withUnconfined { } }","title":"WithContext"},{"location":"dispatch-core/#flow","text":"Like withContext , Flow typically doesn\u2019t get a CoroutineScope of its own. They inherit the coroutineContext from the collector in a pattern called context preservation . These new operators maintain context preservation ( they\u2019re forced to, actually ), and extract the coroutineContext from the collector. val someFlow = flow { } . flowOnDefault () . flowOnIO () . flowOnMain () . flowOnMainImmediate () . flowOnUnconfined ()","title":"Flow"},{"location":"dispatch-core/#defaultdispatcherprovider","text":"The simplest way to get up and running with Dispatch. All library access to a CoroutineContext's DispatcherProvider filters through a single extension property: public val CoroutineContext . dispatcherProvider : DispatcherProvider get () = get ( DispatcherProvider ) ?: DefaultDispatcherProvider . get () If the receiver does not have a DispatcherProvider , the value from DefaultDispatcherProvider will be returned. In practice, this brings at least two benefits:","title":"DefaultDispatcherProvider"},{"location":"dispatch-core/#out-of-box-default-functionality","text":"Calls such as launchIO { ... } or withMain { ... } are safe to use (guaranteed to have a DispatcherProvider ) regardless of the source of the CoroutineContext or CoroutineScope and without any additional configuration. By default, they will access the corresponding CoroutineDispatchers from the Dispatchers singleton.","title":"Out-of-box default functionality"},{"location":"dispatch-core/#easy-global-dispatcher-overrides","text":"DefaultDispatcherProvider has similar set / reset functionality to the Dispatchers.setMain / Dispatchers.resetMain extensions in kotlinx-coroutines-test , except it doesn't need to be confined to testing. You can use DefaultDispatcherProvider.set to globally set a custom implementation at the beginning of an application's lifecycle, but the most likely use-case is certainly in testing. @Test fun `my test` () = runBlocking { DefaultDispatcherProvider . set ( TestDispatcherProvider ()) withMain { // this would normally crash without using Dispatchers.setMain // but \"main\" here comes from the TestDispatcherProvider created above -- not Dispatchers.Main } DefaultDispatcherProvider . reset () // from dispatch-test } See dispatch-test and TestDispatcherProvider","title":"Easy global dispatcher overrides"},{"location":"dispatch-core/#minimum-gradle-config","text":"Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) }","title":"Minimum Gradle Config"},{"location":"dispatch-detekt/","text":"Module Dispatch-Detekt \u00b6 Contents \u00b6 Rules Setup Adding new dependencies Configuration Gradle Daemon bug Rules \u00b6 Name Description AndroidXLifecycleScope Looks for accidental usage of the androidx lifecyclescope extension. HardCodedDispatcher Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton. Setup \u00b6 If you don't already have Detekt set up in your project, follow the official quick start guide . After that is working, you need to add dependencies for the Detekt CLI and these extension rules to each module which will be analyzed. The easiest way to do this is to apply them from the root project -level gradle file. Adding new dependencies \u00b6 In root project-level build.gradle or build.gradle.kts : allprojects { dependencies { detekt ( \"io.gitlab.arturbosch.detekt:detekt-cli:1.14.2\" ) detektPlugins ( \"com.rickbusarow.dispatch:dispatch-detekt:1.0.0-beta06\" ) } } Configuration \u00b6 After adding the dependencies, you'll want to add parameters to your detekt config .yml file. If you don't already have a config file, you can create one by invoking: ./gradlew detektGenerateConfig Then, add the following to the bottom of the detekt-config.yml file: dispatch : active : true # disables all dispatch checks AndroidXLifecycleScope : # incorrect lifecycleScope active : true HardCodedDispatcher : # finds usage of Dispatchers.______ active : true allowDefaultDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Default allowIODispatcher : false # if true, Detekt will ignore all usage of Dispatchers.IO allowMainDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Main allowMainImmediateDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Main.immediate allowUnconfinedDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Unconfined Gradle Daemon bug \u00b6 There is an issue with ClassLoader caching which may cause issues the first time running Detekt. The workaround is to execute ./gradlew --stop once via command line. You should only ever need to do this one time, if at all. The fix for this has already been merged into Detekt.","title":"detekt"},{"location":"dispatch-detekt/#module-dispatch-detekt","text":"","title":"Module Dispatch-Detekt"},{"location":"dispatch-detekt/#contents","text":"Rules Setup Adding new dependencies Configuration Gradle Daemon bug","title":"Contents"},{"location":"dispatch-detekt/#rules","text":"Name Description AndroidXLifecycleScope Looks for accidental usage of the androidx lifecyclescope extension. HardCodedDispatcher Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton.","title":"Rules"},{"location":"dispatch-detekt/#setup","text":"If you don't already have Detekt set up in your project, follow the official quick start guide . After that is working, you need to add dependencies for the Detekt CLI and these extension rules to each module which will be analyzed. The easiest way to do this is to apply them from the root project -level gradle file.","title":"Setup"},{"location":"dispatch-detekt/#adding-new-dependencies","text":"In root project-level build.gradle or build.gradle.kts : allprojects { dependencies { detekt ( \"io.gitlab.arturbosch.detekt:detekt-cli:1.14.2\" ) detektPlugins ( \"com.rickbusarow.dispatch:dispatch-detekt:1.0.0-beta06\" ) } }","title":"Adding new dependencies"},{"location":"dispatch-detekt/#configuration","text":"After adding the dependencies, you'll want to add parameters to your detekt config .yml file. If you don't already have a config file, you can create one by invoking: ./gradlew detektGenerateConfig Then, add the following to the bottom of the detekt-config.yml file: dispatch : active : true # disables all dispatch checks AndroidXLifecycleScope : # incorrect lifecycleScope active : true HardCodedDispatcher : # finds usage of Dispatchers.______ active : true allowDefaultDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Default allowIODispatcher : false # if true, Detekt will ignore all usage of Dispatchers.IO allowMainDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Main allowMainImmediateDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Main.immediate allowUnconfinedDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Unconfined","title":"Configuration"},{"location":"dispatch-detekt/#gradle-daemon-bug","text":"There is an issue with ClassLoader caching which may cause issues the first time running Detekt. The workaround is to execute ./gradlew --stop once via command line. You should only ever need to do this one time, if at all. The fix for this has already been merged into Detekt.","title":"Gradle Daemon bug"},{"location":"dispatch-test-junit4/","text":"Module dispatch-test-junit4 \u00b6 Contents \u00b6 Features Setting Dispatchers.Main This module replaces dispatch-test JUnit dependencies Minimum Gradle Config JUnit 5 interoperability Features \u00b6 In addition to all the functionality in dispatch-test , this module exposes a TestCoroutineRule to handle set-up and tear-down of a TestProvidedCoroutineScope . Since TestProvidedCoroutineScope is a TestCoroutineScope , this Rule also invokes cleanupTestCoroutines after the test. class SomeClassTest { @JvmField @Rule val rule = TestCoroutineRule () @Test fun `some test` () = runBlocking { val subject = SomeClass ( rule ) val job = subject . fireAndForget () // TODO: assertions go here } } class SomeClass ( val coroutineScope : CoroutineScope ) { fun fireAndForget () = launch { } } Setting Dispatchers.Main \u00b6 Even though dispatch-core eliminates the need to use Dispatchers.Main in internal code, it\u2019s still possible that code which has yet to be migrated, or a third-party library is making use of the hard-coded dispatcher. Because of this, the rule still calls Dispatchers.setMain(...) in its setup and Dispatchers.resetMain() afterwards. This module replaces dispatch-test \u00b6 If using this module, there is no need to include the dispatch-test artifact in your dependencies. JUnit dependencies \u00b6 Minimum Gradle Config \u00b6 Because this is a JUnit 4 Rule, it requires a variant of that artifact. No external libraries are bundled as part of Dispatch, so you\u2019ll need to add it to your dependencies block yourself. The two official options would be: classic JUnit 4 org.junit.jupiter:junit-jupiter:4.13 JUnit 5 \"vintage\" org.junit.vintage:junit-vintage-engine:5.5.1 Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { // core implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) // the junit4 artifact also provides the dispatch-test artifact testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta06\" ) testImplementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.4.1\" ) } JUnit 5 interoperability \u00b6 Junit 5 provides a \u201cvintage\u201d (JUnit 4) artifact for legacy support (such as Robolectric or Android instrumented tests). Dispatch also supports running both in the same project by just adding both artifacts. Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { // core implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) // the junit4 and junit5 artifacts also provides the dispatch-test artifact testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta06\" ) testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit5:1.0.0-beta06\" ) testImplementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.4.1\" ) }","title":"test-junit4"},{"location":"dispatch-test-junit4/#module-dispatch-test-junit4","text":"","title":"Module dispatch-test-junit4"},{"location":"dispatch-test-junit4/#contents","text":"Features Setting Dispatchers.Main This module replaces dispatch-test JUnit dependencies Minimum Gradle Config JUnit 5 interoperability","title":"Contents"},{"location":"dispatch-test-junit4/#features","text":"In addition to all the functionality in dispatch-test , this module exposes a TestCoroutineRule to handle set-up and tear-down of a TestProvidedCoroutineScope . Since TestProvidedCoroutineScope is a TestCoroutineScope , this Rule also invokes cleanupTestCoroutines after the test. class SomeClassTest { @JvmField @Rule val rule = TestCoroutineRule () @Test fun `some test` () = runBlocking { val subject = SomeClass ( rule ) val job = subject . fireAndForget () // TODO: assertions go here } } class SomeClass ( val coroutineScope : CoroutineScope ) { fun fireAndForget () = launch { } }","title":"Features"},{"location":"dispatch-test-junit4/#setting-dispatchersmain","text":"Even though dispatch-core eliminates the need to use Dispatchers.Main in internal code, it\u2019s still possible that code which has yet to be migrated, or a third-party library is making use of the hard-coded dispatcher. Because of this, the rule still calls Dispatchers.setMain(...) in its setup and Dispatchers.resetMain() afterwards.","title":"Setting Dispatchers.Main"},{"location":"dispatch-test-junit4/#this-module-replaces-dispatch-test","text":"If using this module, there is no need to include the dispatch-test artifact in your dependencies.","title":"This module replaces dispatch-test"},{"location":"dispatch-test-junit4/#junit-dependencies","text":"","title":"JUnit dependencies"},{"location":"dispatch-test-junit4/#minimum-gradle-config","text":"Because this is a JUnit 4 Rule, it requires a variant of that artifact. No external libraries are bundled as part of Dispatch, so you\u2019ll need to add it to your dependencies block yourself. The two official options would be: classic JUnit 4 org.junit.jupiter:junit-jupiter:4.13 JUnit 5 \"vintage\" org.junit.vintage:junit-vintage-engine:5.5.1 Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { // core implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) // the junit4 artifact also provides the dispatch-test artifact testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta06\" ) testImplementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.4.1\" ) }","title":"Minimum Gradle Config"},{"location":"dispatch-test-junit4/#junit-5-interoperability","text":"Junit 5 provides a \u201cvintage\u201d (JUnit 4) artifact for legacy support (such as Robolectric or Android instrumented tests). Dispatch also supports running both in the same project by just adding both artifacts. Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { // core implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) // the junit4 and junit5 artifacts also provides the dispatch-test artifact testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta06\" ) testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit5:1.0.0-beta06\" ) testImplementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.4.1\" ) }","title":"JUnit 5 interoperability"},{"location":"dispatch-test-junit5/","text":"Module dispatch-test-junit5 \u00b6 Contents \u00b6 Features CoroutineTest example CoroutineTestExtension example Setting Dispatchers.Main This module replaces dispatch-test JUnit dependencies Minimum Gradle Config JUnit 4 interoperability Features \u00b6 In addition to all the functionality in dispatch-test , this module exposes a JUnit 5 CoroutineTestExtension and CoroutineTest annotation to handle set-up and tear-down of a TestProvidedCoroutineScope . Since TestProvidedCoroutineScope is a TestCoroutineScope , this Extension also invokes cleanupTestCoroutines after the test. CoroutineTest example \u00b6 @CoroutineTest ( CustomScopeFactory :: class ) class SomeClassTest ( val testScope : TestProvidedCoroutineScope ) { @Test fun `some test` () = runBlocking { val subject = SomeClass ( testScope ) val job = subject . fireAndForget () // TODO: assertions go here } } class SomeClass ( val coroutineScope : CoroutineScope ) { fun fireAndForget () = launch { } } class CustomScopeFactory : CoroutineTestExtension . ScopeFactory () { override fun create () = TestProvidedCoroutineScope ( context = Job ()) } CoroutineTestExtension example \u00b6 class SomeClassTest { @JvmField @RegisterExtension val extension = CoroutineTestExtension () @Test fun `some test` ( scope : TestProvidedCoroutineScope ) = runBlocking { val subject = SomeClass ( scope ) val job = subject . fireAndForget () // TODO: assertions go here } } class SomeClass ( val coroutineScope : CoroutineScope ) { fun fireAndForget () = launch { } } Setting Dispatchers.Main \u00b6 Even though dispatch-core eliminates the need to use Dispatchers.Main in internal code, it\u2019s still possible that code which has yet to be migrated, or a third-party library is making use of the hard-coded dispatcher. Because of this, the extension still calls Dispatchers.setMain(...) in its setup and Dispatchers.resetMain() afterwards. This module replaces dispatch-test \u00b6 If using this module, there is no need to include the dispatch-test artifact in your dependencies. JUnit dependencies \u00b6 Minimum Gradle Config \u00b6 Because this is a JUnit 5 Extension, it requires a the JUnit 5 artifact. No external libraries are bundled as part of Dispatch, so you\u2019ll need to add it to your dependencies block yourself. org.junit.jupiter:junit-jupiter:5.6.2 Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { // core implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) // the junit5 artifact also provides the dispatch-test artifact testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit5:1.0.0-beta06\" ) testImplementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.4.1\" ) testImplementation ( \"org.junit.jupiter:junit-jupiter:5.7.0\" ) } JUnit 4 interoperability \u00b6 Junit 4 provides a \u201cvintage\u201d (JUnit 4) artifact for legacy support (such as Robolectric or Android instrumented tests). Dispatch also supports running both in the same project by just adding both artifacts. Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { // core implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) // the junit4 and junit5 artifacts also provides the dispatch-test artifact testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta06\" ) testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit5:1.0.0-beta06\" ) testImplementation ( \"org.junit.jupiter:junit-jupiter:5.7.0\" ) testImplementation ( \"org.junit.vintage:junit-vintage-engine:5.7.0\" ) testImplementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.4.1\" ) }","title":"test-junit5"},{"location":"dispatch-test-junit5/#module-dispatch-test-junit5","text":"","title":"Module dispatch-test-junit5"},{"location":"dispatch-test-junit5/#contents","text":"Features CoroutineTest example CoroutineTestExtension example Setting Dispatchers.Main This module replaces dispatch-test JUnit dependencies Minimum Gradle Config JUnit 4 interoperability","title":"Contents"},{"location":"dispatch-test-junit5/#features","text":"In addition to all the functionality in dispatch-test , this module exposes a JUnit 5 CoroutineTestExtension and CoroutineTest annotation to handle set-up and tear-down of a TestProvidedCoroutineScope . Since TestProvidedCoroutineScope is a TestCoroutineScope , this Extension also invokes cleanupTestCoroutines after the test.","title":"Features"},{"location":"dispatch-test-junit5/#coroutinetest-example","text":"@CoroutineTest ( CustomScopeFactory :: class ) class SomeClassTest ( val testScope : TestProvidedCoroutineScope ) { @Test fun `some test` () = runBlocking { val subject = SomeClass ( testScope ) val job = subject . fireAndForget () // TODO: assertions go here } } class SomeClass ( val coroutineScope : CoroutineScope ) { fun fireAndForget () = launch { } } class CustomScopeFactory : CoroutineTestExtension . ScopeFactory () { override fun create () = TestProvidedCoroutineScope ( context = Job ()) }","title":"CoroutineTest example"},{"location":"dispatch-test-junit5/#coroutinetestextension-example","text":"class SomeClassTest { @JvmField @RegisterExtension val extension = CoroutineTestExtension () @Test fun `some test` ( scope : TestProvidedCoroutineScope ) = runBlocking { val subject = SomeClass ( scope ) val job = subject . fireAndForget () // TODO: assertions go here } } class SomeClass ( val coroutineScope : CoroutineScope ) { fun fireAndForget () = launch { } }","title":"CoroutineTestExtension example"},{"location":"dispatch-test-junit5/#setting-dispatchersmain","text":"Even though dispatch-core eliminates the need to use Dispatchers.Main in internal code, it\u2019s still possible that code which has yet to be migrated, or a third-party library is making use of the hard-coded dispatcher. Because of this, the extension still calls Dispatchers.setMain(...) in its setup and Dispatchers.resetMain() afterwards.","title":"Setting Dispatchers.Main"},{"location":"dispatch-test-junit5/#this-module-replaces-dispatch-test","text":"If using this module, there is no need to include the dispatch-test artifact in your dependencies.","title":"This module replaces dispatch-test"},{"location":"dispatch-test-junit5/#junit-dependencies","text":"","title":"JUnit dependencies"},{"location":"dispatch-test-junit5/#minimum-gradle-config","text":"Because this is a JUnit 5 Extension, it requires a the JUnit 5 artifact. No external libraries are bundled as part of Dispatch, so you\u2019ll need to add it to your dependencies block yourself. org.junit.jupiter:junit-jupiter:5.6.2 Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { // core implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) // the junit5 artifact also provides the dispatch-test artifact testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit5:1.0.0-beta06\" ) testImplementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.4.1\" ) testImplementation ( \"org.junit.jupiter:junit-jupiter:5.7.0\" ) }","title":"Minimum Gradle Config"},{"location":"dispatch-test-junit5/#junit-4-interoperability","text":"Junit 4 provides a \u201cvintage\u201d (JUnit 4) artifact for legacy support (such as Robolectric or Android instrumented tests). Dispatch also supports running both in the same project by just adding both artifacts. Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { // core implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) // the junit4 and junit5 artifacts also provides the dispatch-test artifact testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta06\" ) testImplementation ( \"com.rickbusarow.dispatch:dispatch-test-junit5:1.0.0-beta06\" ) testImplementation ( \"org.junit.jupiter:junit-jupiter:5.7.0\" ) testImplementation ( \"org.junit.vintage:junit-vintage-engine:5.7.0\" ) testImplementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.4.1\" ) }","title":"JUnit 4 interoperability"},{"location":"dispatch-test/","text":"Module dispatch-test \u00b6 Test helpers for the dispatch-core module. Most of the tools you need to automatically handle DispatcherProvider in your tests. (see dispatch-test-junit4 or dispatch-test-junit5 for the rest.) Contents \u00b6 TestDispatcherProvider Constructor with default arguments Single-arg factory Basic TestDispatcherProvider TestProvidedCoroutineScope Builders Minimum Gradle Config TestDispatcherProvider \u00b6 Testing version of the DispatcherProvider with three main styles of creation: Constructor with default arguments \u00b6 (link) Each property becomes its own TestCoroutineDispatcher by default, but may be replaced by any CoroutineDispatcher . val customTestDispatcherProvider = TestDispatcherProvider ( default = newSingleThreadContext ( \"default\" ), io = newSingleThreadContext ( \"io\" ), main = newSingleThreadContext ( \"main\" ), mainImmediate = newSingleThreadContext ( \"main immediate\" ), unconfined = newSingleThreadContext ( \"unconfined\" ) ) val defaultTetsDispatcherProvider = TestDispatcherProvider () Single-arg factory \u00b6 (link) Another option is to pass a single CoroutineDispatcher , which is then used to populate all fields. val dispatcher = newSingleThreadContext ( \"custom\" ) val dispatcherProvider = TestDispatcherProvider ( dispatcher ) dispatcherProvider . default shouldBe myDispatcher dispatcherProvider . io shouldBe myDispatcher dispatcherProvider . main shouldBe myDispatcher dispatcherProvider . mainImmediate shouldBe myDispatcher dispatcherProvider . unconfined shouldBe myDispatcher Basic TestDispatcherProvider \u00b6 (link) Sometimes we want to have the normal dispatch behaviors of a production environment, just without the awkward mechanics of Dispatchers.setMain . This is essentially DefaultDispatcherProvider except with a single-threaded executor handling the \"main\" thread. fun TestBasicDispatcherProvider (): TestDispatcherProvider { val mainThread = newSingleThreadContext ( \"main thread proxy\" ) return TestDispatcherProvider ( default = Dispatchers . Default , io = Dispatchers . IO , main = mainThread , mainImmediate = mainThread , unconfined = Dispatchers . Unconfined ) } TestProvidedCoroutineScope \u00b6 (link) A polymorphic CoroutineScope which implements all the type-safe versions from dispatch-core , as well as TestCoroutineScope . This type may be injected anywhere, regardless of the requirement. Builders \u00b6 Sometimes, instead of explicitly creating a CoroutineScope object, we prefer to just use a coroutineScope builder function within a function. @Test fun some_test () = runBlockingProvided { someSuspendFunction () } @Test fun some_test () = testProvided { someSuspendFunctionWithADelay () } Name Description runBlockingProvided Uses runBlocking , but injects a DispatcherProvider into its CoroutineScope . Use this function if you want normal dispatch behavior. testProvided Uses runBlockingTest , but injects a DispatcherProvider into its TestCoroutineScope . Use this function if you want the explicit time control of runBlockingTest . Minimum Gradle Config \u00b6 Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { // core implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) testImplementation ( \"com.rickbusarow.dispatch:dispatch-test:1.0.0-beta06\" ) testImplementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.4.1\" ) }","title":"test-core"},{"location":"dispatch-test/#module-dispatch-test","text":"Test helpers for the dispatch-core module. Most of the tools you need to automatically handle DispatcherProvider in your tests. (see dispatch-test-junit4 or dispatch-test-junit5 for the rest.)","title":"Module dispatch-test"},{"location":"dispatch-test/#contents","text":"TestDispatcherProvider Constructor with default arguments Single-arg factory Basic TestDispatcherProvider TestProvidedCoroutineScope Builders Minimum Gradle Config","title":"Contents"},{"location":"dispatch-test/#testdispatcherprovider","text":"Testing version of the DispatcherProvider with three main styles of creation:","title":"TestDispatcherProvider"},{"location":"dispatch-test/#constructor-with-default-arguments","text":"(link) Each property becomes its own TestCoroutineDispatcher by default, but may be replaced by any CoroutineDispatcher . val customTestDispatcherProvider = TestDispatcherProvider ( default = newSingleThreadContext ( \"default\" ), io = newSingleThreadContext ( \"io\" ), main = newSingleThreadContext ( \"main\" ), mainImmediate = newSingleThreadContext ( \"main immediate\" ), unconfined = newSingleThreadContext ( \"unconfined\" ) ) val defaultTetsDispatcherProvider = TestDispatcherProvider ()","title":"Constructor with default arguments"},{"location":"dispatch-test/#single-arg-factory","text":"(link) Another option is to pass a single CoroutineDispatcher , which is then used to populate all fields. val dispatcher = newSingleThreadContext ( \"custom\" ) val dispatcherProvider = TestDispatcherProvider ( dispatcher ) dispatcherProvider . default shouldBe myDispatcher dispatcherProvider . io shouldBe myDispatcher dispatcherProvider . main shouldBe myDispatcher dispatcherProvider . mainImmediate shouldBe myDispatcher dispatcherProvider . unconfined shouldBe myDispatcher","title":"Single-arg factory"},{"location":"dispatch-test/#basic-testdispatcherprovider","text":"(link) Sometimes we want to have the normal dispatch behaviors of a production environment, just without the awkward mechanics of Dispatchers.setMain . This is essentially DefaultDispatcherProvider except with a single-threaded executor handling the \"main\" thread. fun TestBasicDispatcherProvider (): TestDispatcherProvider { val mainThread = newSingleThreadContext ( \"main thread proxy\" ) return TestDispatcherProvider ( default = Dispatchers . Default , io = Dispatchers . IO , main = mainThread , mainImmediate = mainThread , unconfined = Dispatchers . Unconfined ) }","title":"Basic TestDispatcherProvider"},{"location":"dispatch-test/#testprovidedcoroutinescope","text":"(link) A polymorphic CoroutineScope which implements all the type-safe versions from dispatch-core , as well as TestCoroutineScope . This type may be injected anywhere, regardless of the requirement.","title":"TestProvidedCoroutineScope"},{"location":"dispatch-test/#builders","text":"Sometimes, instead of explicitly creating a CoroutineScope object, we prefer to just use a coroutineScope builder function within a function. @Test fun some_test () = runBlockingProvided { someSuspendFunction () } @Test fun some_test () = testProvided { someSuspendFunctionWithADelay () } Name Description runBlockingProvided Uses runBlocking , but injects a DispatcherProvider into its CoroutineScope . Use this function if you want normal dispatch behavior. testProvided Uses runBlockingTest , but injects a DispatcherProvider into its TestCoroutineScope . Use this function if you want the explicit time control of runBlockingTest .","title":"Builders"},{"location":"dispatch-test/#minimum-gradle-config","text":"Add to your module's build.gradle.kts : repositories { mavenCentral () } dependencies { // core implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.1\" ) implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\" ) implementation ( \"com.rickbusarow.dispatch:dispatch-core:1.0.0-beta06\" ) testImplementation ( \"com.rickbusarow.dispatch:dispatch-test:1.0.0-beta06\" ) testImplementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.4.1\" ) }","title":"Minimum Gradle Config"}]}